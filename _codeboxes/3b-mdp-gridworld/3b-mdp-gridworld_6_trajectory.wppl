// trajectory must consist only of states. This can be done by calling
// *simulateMDP* with an additional final argument 'states'.
var getExpectedUtilitiesMDP = function(stateTrajectory, world, agent) {
  var eu = agent.expectedUtility;
  var stateToActions = world.stateToActions;
  var getAllExpectedUtilities = function(state) {
    var availableActions = stateToActions(state);
    return [state, map(function(action){return eu(state, action);},
		       availableActions)];
  };
  return map(getAllExpectedUtilities, stateTrajectory);
};

// long route better and takes long route

var noiseProb = 0.03;
var world = makeHike(noiseProb, {big: true});
var feature = world.feature;

var alpha = 100;
var utilityTable = {East: 10, West: 7, Hill : -40, timeCost: -0.4};
var utility = mdpTableToUtilityFunction(utilityTable, feature);
var agent = makeMDPAgent({utility: utility, alpha: alpha}, world);

var startState = {loc: [1,1],
		  timeLeft: 12,
		  terminateAfterAction: false,
		  timeAtRestaurant: 1};

var trajectory = simulateMDP(startState, world, agent, 'states');
var locs1 = map(function(state){return state.loc;}, trajectory);
var eus = getExpectedUtilitiesMDP(trajectory, world, agent);
// figure out nice way to display locations and expected utilities


// GridWorld.draw(params, { 
//   labels: params.labels,
//   trajectory: trajectoryExpUtilities, 
//   expUtilities: trajectoryExpUtilities
// });


// TODO FIX: stochastic expUtilities and doesnt take highest EU
// action despite low noise.

// note that this problem persists with the new gridworld mdp functions

var noiseProb = .04;
var world = makeHike(noiseProb, {big: true});
var feature = world.feature;

var alpha = 100;
var utilityTable = { East: 15, West: 7, Hill: -40, timeCost: -.8 };
var utility = mdpTableToUtilityFunction(utilityTable, feature);
var agent = makeMDPAgent({utility: utility, alpha: alpha}, world);

var startState = {loc: [1,1],
		          timeLeft: 14,
				  terminateAfterAction: false,
				  timeAtRestaurant: 1};

var trajectory = simulateMDP(startState, world, agent, 'states');
var eus = getExpectedUtilitiesMDP(trajectory, world, agent);

var locs2 = map(function(state){return state.loc;}, trajectory);
// locs1;
locs2;
