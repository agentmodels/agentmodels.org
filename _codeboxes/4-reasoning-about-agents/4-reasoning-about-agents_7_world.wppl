var world = restaurantChoiceMDP;
var feature = world.feature;

var utilityTablePrior = function(){
  var foodValues = [0,1,2,3];
  var timeCostValues = [-0.1, -0.3, -0.6, -1];
  var donut = uniformDraw(foodValues);

  return {'Donut N': donut,
          'Donut S': donut,
          Veg: uniformDraw(foodValues),
          Noodle: uniformDraw(foodValues),
          timeCost: uniformDraw(timeCostValues)};
};
var alphaPrior = function(){return uniformDraw([.1,1,10,100]);};

var posterior = function(observedStateActionSequence){
  return Enumerate( function() {
    var utilityTable = utilityTablePrior();
    var alpha = alphaPrior();
    var params = {utility: mdpTableToUtilityFunction(utilityTable, feature),
		          alpha: alpha};
    var agent = makeMDPAgent(params, world);
    var act = agent.act;

    var donutBest = utilityTable['Donut N'] >= utilityTable['Veg']
	  && utilityTable['Donut N'] >= utilityTable['Noodle'];

    map( function(stateAction){
      factor( act(stateAction[0]).score( [], stateAction[1]) );
    }, observedStateActionSequence );

    return {donutBest: donutBest, logalpha: Math.log10(alpha),
	        timeCost: utilityTable.timeCost};
  });
};
  
var observedSequence1 =  locationsToStateActions(restaurantNameToPath.donutSouth);
var observedSequence2 =  locationsToStateActions(restaurantNameToPath.donutNorth);
// same problem with printing the posterior as previous codebox
// posterior(observedSequence1.concat(observedSequence2));
  // TODO: alternatively: can we run *score* on an array for more efficient computation of likelihoods
  // e.g. score([],[x1,x2]), where the function computes sufficient statistics of the input 
  
