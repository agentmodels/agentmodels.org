// We use the WebPPL-gridworld library
var world = makeDonutWorld2({big: true});
var transition = world.transition;
var gridLocationToRestaurant = world.feature;
var utilityTable = {'Donut S': 1, 'Donut N': 1, 'Veg': 3,
                    'Noodle': 2, 'timeCost': -0.1};
var tableToUtilityFunction = function(table, feature) {  
  return function(state, action) {
    var stateFeatureName = feature(state).name;
    if (stateFeatureName) {
      return table[stateFeatureName];
    } else {
      return table.timeCost;
    }
  };
};
var utility = tableToUtilityFunction(utilityTable, gridLocationToRestaurant);
var stateToActions = world.stateToActions;
var alpha = 100;

var act = dp.cache(function(state){
  return Enumerate(function(){
    var action = uniformDraw(stateToActions(state));
    var eu = expectedUtility(state, action);
    factor(alpha * eu);
    return action;
  });
});

var expectedUtility = dp.cache(function(state, action){
  var u = utility(state, action);
  
  if (state.terminateAfterAction){
    return u; 
  } else {                     
    return u + expectation(Enumerate(function(){
      var nextState = transition(state, action);
      var nextAction = sample(act(nextState));
      return expectedUtility(nextState, nextAction);  
    }));
  }
});

var simulate = function(startState){
  
  var sampleSequence = function(state){
    var action = sample(act(state));
    var nextState = transition(state, action);
	var out = [state.loc, action];
    return state.terminateAfterAction ? [out]
	  : [out].concat(sampleSequence(nextState));
  };
  return sampleSequence(startState);
};

var startState = {loc: [3,1],
                  terminateAfterAction: false,
                  timeLeft: 9,
                  timeAtRestaurant: 1};
var locActionPairs = simulate(startState);

locActionPairs;

// GridWorld.draw(world, {trajectory : locActionPairs});
