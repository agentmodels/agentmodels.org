// code for chapt 3


var argMax = function(f,ar){return maxWith(f,ar)[0]}

var firstExample = function(){

  var consequence = function(action){
    var table = { italian:'pizza', french:'no pizza' }
    return table[action]
  }
  
  var utility = function(consequence){
    return consequence == 'pizza' ? 1 : 0
  }
  
  // maxing agent
  var maxAgent = function(){
    return utility(consequence('italian')) > utility(consequence('french')) ? 'italian' : 'french'
  }
  

  // planning as inference agent
  
  var agent = function(){
    return Enumerate(function(){
      var action = uniformDraw(['french', 'italian'])
      condition( consequence(action) == 'pizza' )
    return action
    })
  }


  // dynamic Q values
  // make webppl package. need npm and package.JSON. stuff. these will be compiled and so go into agent models entire JSON. 
  // webppl-editor has lowlevel fucntion for talking to rest of page
  // make repo under agentModels group  webppl-gridworld
  
  
  // probabilistic outcomes
  var consequence = function(action){
    var table = { italian: [0.2, 0.6, 0.2], french: [0.05, 0.9, .05] }
    return categorical( table[action], ['bad', 'good', 'spectacular'] )
  };

  var utility = function(consequence){
    var table = {bad: -10, good: 6, spectacular:8};
    return table[consequence];
  };

  var maxEUAgent = function(){
    var EU = function(action){
      return expectation( Enumerate( function(){
        return utility(consequence(action));
      }));
    };
    return argMax( EU, ['italian', 'french'] );
  };
    
 
  var agent = function(){
    return Enumerate(function(){
      var action = uniformDraw(['french', 'italian'])
      var EU = function(action){
        return expectation( Enumerate( function(){
          return utility(consequence(action));
        }));
      };
      condition( EU(action) > 5 )
      return action;
    })
  };
  
  


  
  return {maxAgent: maxAgent(), agent: sample(agent())}
}


var secondExample = function(){
  // multi-attribute: find best restaurant, given features
  
  var consequence = function(action){
    var restaurantToVector = { 1: [2, 9, 9], // [price, food, location]
                               2: [4, 6, 7],
                               3: [9, 4, 7] }
    return restaurantToVector[action]
  }
  

  var utility = function(vector){
    return vector[0]*0.8 + vector[1]*0.9 + vector[2]*0.5
  }
  
  var argMax = function(f,ar){return maxWith(f,ar)[0]}
  
  
  var maxAgent = function(){
    return argMax( function(action){return utility(consequence(action))}, [1,2,3])
  }

  var agent = function(){
    return Enumerate(function(){
      var action = uniformDraw([1,2,3])
      condition( utility(consequence(action)) > 13 )
    return action
    })
  }

  return {maxAgent: maxAgent(), agent: [sample(agent()), sample(agent()), sample(agent()), sample(agent())]}
}

// example with two actions. agent calls function 'agent at next timestep'. agent at timestep1 is agent's model of itself.
// maybe its wrong. well see both cases later. could illustrate failure of this explicitly in biases section by
// showing the two different models. 



console.log('ag', firstExample(), secondExample())
                                                
  


